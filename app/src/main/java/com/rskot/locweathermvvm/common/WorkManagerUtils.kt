package com.rskot.locweathermvvm.common

import android.content.Context
import android.util.Log
import androidx.lifecycle.LiveData
import androidx.work.*
import java.util.concurrent.TimeUnit

private const val TAG = "WorkManagerUtils"

/**
 * Utility class manages the work manager activities
 */
object WorkManagerUtils {
    private const val WORK_NAME = "weatherUpdates"

    /**
     * Starts the weather updates in work manager schedular
     */
    fun startWeatherUpdates(context: Context) {
        Log.d(TAG, "startWeatherUpdates() context=$context")
        val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.UNMETERED)
                .build()

        val workRequest = PeriodicWorkRequestBuilder<WeatherInfoWorker>(2, TimeUnit.HOURS)
                .setConstraints(constraints)
                //Do not call execute again in case of failure but after backoff
                .setBackoffCriteria(BackoffPolicy.LINEAR, OneTimeWorkRequest.MIN_BACKOFF_MILLIS, TimeUnit.MILLISECONDS)
                .build()

        //Unique work is a powerful concept that guarantees that you only have one instance of work with a particular name at a time. Unlike IDs, unique names are human-readable and specified by the developer instead of being auto-generated by WorkManager.
        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
                WORK_NAME,
                //If there is existing pending (uncompleted) work with the same unique name, do nothing. Otherwise, insert the newly-specified work.
                ExistingPeriodicWorkPolicy.KEEP,
                workRequest)
    }

    /**
     * Gets a {@link LiveData} of the {@link WorkInfo} for all work in a work chain with a given
     * unique name.
     *
     * @param context The context
     */
    fun getWeatherUpdatesInfo(context: Context): LiveData<List<WorkInfo>> {
        return WorkManager.getInstance(context).getWorkInfosForUniqueWorkLiveData(WORK_NAME)
    }
}